# Progetto Lab2 24/25: (in fase di modofica)
Testo: https://elearning.di.unipi.it/mod/page/view.php?id=22794 (progetto ridotto)

***Specifiche richieste dal progetto!***

## CreaGrafo.java
**1. Parsing delle righe:** Si apre il ciclo while fino a che non terminano le righe da leggere (e di cui fare il parsing). All'interno del while si esegue il parsing di una riga letta: 1. si esegue **String.split("\t")** così da ricavare i campi della linea definiti nella prima riga del file (che sappiamo essere separati da "\t"); 2. per **verificare la "validità"** della linea controlliamo il campo contenente l'anno di nascita (campi[2]!=\N), e se tra le professioni (campi[4]) abbiamo attore/attrice (si usa .contains(substring) per verificare) tra le professioni. 
Se le cond. sono verificate allora la linea è valida e si ricava un istanza di Attore dalla linea, inserendola nella mappa <codice,Attore> che usiamo nel programma. Alla fine del while chiuderemo il file e procederemo col resto del programma.  


## cammini.c
**2. Implementazione della coda FIFO:** (dopo svariati test) si implementa la coda FIFO all'interno della BFS per la visita del grafo come un **array di puntatori ad attori** (attore** ).
In particolare è implementata una struct (utils.h) FIFO contenente vari campi per l'uso efficiente della coda: **head e tail**= interi per estrazione ed inserimento, **cap**= capacita dell'array usato (fondamentale in caso di realloc), e **queue**= array di puntatori ad attore.
NOTA: l'uso di indici di inseriemnto ed estrazione implementano operazioni di push e pop in O(1), ma lasciano anche una **parte dell'array inutilizato** (la parte prima di head rimane inutilizzata senza "ottimizzazioni")! Per questo motivo al momento della push (quando controllo se è necessaria una realloc) cerco di sfruttare, se possibile, lo spazio formatosi prima di head: utilizzo **la funzione memmove** (spiegazione anche in corrispodenza dell'utilizzo) che sposta (/copia) n bytes da un indirizzo src ad un altro (indirizzo) dest; lo uso in alcuni casi per risparmiarmi una realloc e riciclare spazio già allocato.

**3. Ricostruzione cammini minimi:** Per la gestione delle stampe usiamo una funzione dedicata (utils.) che ,in base ad un certo valore di controllo passato, esegue la corretta stampa per ogni esito possibile. 
La funzione **void stampa_minpath()** (nel caso in cui esista un cammino tra a e b) per la ricostruzione del cammino utilizza i campi dei nodi ABR: ognuno di questi nodi contiene un **campo pred** che punta al predecessore del nodo nella BFS, di conseguenza partendo da qualsiasi nodo (destinazione) è possibile ricostruire facilmente il path da destinazione a sorgente. 
Passando alla funzione un puntatore al nodo destinazione questa è in grado di ricostruire il path MA IN ORDINE INVERSO, per leggerlo in modo corretto **ci appoggiamo ad un array (dinamico)** in cui viene temporaneamente salvato la sequenza di nodi (puntatori ad attori) del cammino, e poi letto nell'ordine opportuno per stampare il cammino partendo dalla sorgente fino alla nostra destinazione: si seguono i puntatori predecessori fino alla sorg inserendo nell'array partendo dalla cima, alla fine rileggeremo l'array partendo dal fondo -> **ordine corretto**!  


**4. Gestione SIGINT:** All'inizio del programma nel main viene creato ed avviato un thread gestore del segnale SIGINT, il thread viene avviato con la funzione **handler_body** e gli viene passata come argomento una struttura speciale **datisighand** contenente due flags (variabili condivise con main di tipo "atomic_int") su cui si basa il comportamento dell'handler: **p_state** è un (puntatore) valore condiviso col main thread che rappresenta lo **stato della pipe** (se è stat creata oppure no, se è stata creata si deve terminare nel modo descritto altrimenti si stampa un messaggio di attesa); viene quindi settato dal main al momento della crezione della pipe. **term** invece è un (puntatore) valore sempre condiviso tra main e thread gestore, ma che viene settato solo in caso si riceva un SIGINT dopo il cambio di stato della pipe (viene settato solo da thread gestore); in tal caso il gestore deve **comunicare al main di terminare**, per farlo setta term ad 1 e termina, mentre il main (che dalla creazione della pipe lo controllerà periodicamente) terminerà anch'esso nella modalità richiesta (con exitcode!=0).
Nel caso in cui non si riceva un SIGINT (durante la fase di lettura dalla pipe) e che si giunga alla **fine "naturale" del programma**, per far terminare il thread gestore e joinarlo il **main gli invia tramite pthread_kill() un segnale di SIGINT** (al thread gestore) che lo porta a terminare (settando la var term ad 1 ma non ci interessa) per essere joinato, e terminare però con exitcode= 0.
